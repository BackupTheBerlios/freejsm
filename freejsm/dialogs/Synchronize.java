package dialogs;

/*
 * wait.java
 *
 * Created on 10 septembre 2002, 19:33
 */

/**
 *
 * @author  Labayle Alexandre
 */

import javax.swing.*;
import java.awt.*;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.PreparedStatement;

import java.util.Hashtable;
import java.util.Vector;
import java.util.Enumeration;

public final class Synchronize extends javax.swing.JDialog {
    
   static java.awt.Dimension screenSize = java.awt.Toolkit.getDefaultToolkit().getScreenSize();
    private SendLoop sendLoop;
    private Hashtable fieldsAndValues;
    private Hashtable champsName = new Hashtable();
    private Connection connex;
    private Integer lastID;
    private Hashtable changedID = new Hashtable();
    private boolean enConflit = false;
    private boolean isUpdate = false;
    private Vector parentsID = new Vector();
    private Hashtable lastfieldsAndValues= new Hashtable();
    
    
    /** Creates new form wait */
    public Synchronize(java.awt.Frame parent, boolean modal, Connection connex, Vector tableLevels, Hashtable champsName, Vector parentsID) {
        super(parent, modal);
        initComponents();
        this.setSize(640, 480);
        this.champsName = champsName;
        this.parentsID = parentsID;
        conflictPane.setVisible(false);
    this.setLocation((screenSize.width-(this.getSize().width))/2,(screenSize.height-(this.getSize().height))/2);
        sendLoop = new SendLoop(this, connex, tableLevels);
        
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    private void initComponents() {//GEN-BEGIN:initComponents
        waitingPane = new javax.swing.JPanel();
        jPanel1 = new javax.swing.JPanel();
        jPanel3 = new javax.swing.JPanel();
        jPanel4 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jPanel5 = new javax.swing.JPanel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jPanel6 = new javax.swing.JPanel();
        Progress = new javax.swing.JProgressBar();
        conflictPane = new javax.swing.JPanel();
        jPanel7 = new javax.swing.JPanel();
        slaveSP = new javax.swing.JScrollPane();
        slavePane = new javax.swing.JPanel();
        masterSP = new javax.swing.JScrollPane();
        masterPane = new javax.swing.JPanel();
        radioPane = new javax.swing.JPanel();
        masterRB = new javax.swing.JRadioButton();
        slaveRB = new javax.swing.JRadioButton();
        jPanel2 = new javax.swing.JPanel();
        acceptButton = new javax.swing.JButton();

        getContentPane().setLayout(new javax.swing.BoxLayout(getContentPane(), javax.swing.BoxLayout.Y_AXIS));

        setDefaultCloseOperation(javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE);
        setTitle("Patientez");
        setCursor(new java.awt.Cursor(java.awt.Cursor.WAIT_CURSOR));
        setName("dwait");
        setResizable(false);
        waitingPane.setLayout(new java.awt.BorderLayout());

        waitingPane.setBorder(new javax.swing.border.EtchedBorder());
        jPanel1.setLayout(new java.awt.BorderLayout());

        waitingPane.add(jPanel1, java.awt.BorderLayout.NORTH);

        jPanel4.setBorder(new javax.swing.border.EtchedBorder());
        jLabel1.setIcon(new javax.swing.ImageIcon(getClass().getResource("/org/gnu/icones/48x48/DB/options_querybrowser.png")));
        jPanel4.add(jLabel1);

        jPanel5.setLayout(new java.awt.BorderLayout());

        jLabel3.setFont(new java.awt.Font("Dialog", 0, 12));
        jLabel3.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel3.setText("Op\u00e9ration en cours");
        jPanel5.add(jLabel3, java.awt.BorderLayout.CENTER);

        jLabel4.setFont(new java.awt.Font("Dialog", 0, 12));
        jLabel4.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel4.setText("Patientez svp...");
        jPanel5.add(jLabel4, java.awt.BorderLayout.SOUTH);

        jPanel4.add(jPanel5);

        jPanel4.add(jPanel6);

        jPanel3.add(jPanel4);

        waitingPane.add(jPanel3, java.awt.BorderLayout.CENTER);

        Progress.setMaximum(1000);
        Progress.setIndeterminate(true);
        waitingPane.add(Progress, java.awt.BorderLayout.SOUTH);

        getContentPane().add(waitingPane);

        conflictPane.setLayout(new javax.swing.BoxLayout(conflictPane, javax.swing.BoxLayout.Y_AXIS));

        conflictPane.setMinimumSize(new java.awt.Dimension(640, 480));
        conflictPane.setPreferredSize(new java.awt.Dimension(640, 480));
        jPanel7.setLayout(new javax.swing.BoxLayout(jPanel7, javax.swing.BoxLayout.X_AXIS));

        slavePane.setLayout(new javax.swing.BoxLayout(slavePane, javax.swing.BoxLayout.Y_AXIS));

        slavePane.setBorder(new javax.swing.border.TitledBorder("Version import\u00e9e"));
        slaveSP.setViewportView(slavePane);

        jPanel7.add(slaveSP);

        masterPane.setLayout(new javax.swing.BoxLayout(masterPane, javax.swing.BoxLayout.Y_AXIS));

        masterPane.setBorder(new javax.swing.border.TitledBorder("Version locale"));
        masterSP.setViewportView(masterPane);

        jPanel7.add(masterSP);

        conflictPane.add(jPanel7);

        radioPane.setLayout(new javax.swing.BoxLayout(radioPane, javax.swing.BoxLayout.Y_AXIS));

        masterRB.setText("Version Locale");
        masterRB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                masterRBActionPerformed(evt);
            }
        });

        radioPane.add(masterRB);

        slaveRB.setText("Version import\u00e9e");
        slaveRB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                slaveRBActionPerformed(evt);
            }
        });

        radioPane.add(slaveRB);

        conflictPane.add(radioPane);

        acceptButton.setText("Accepter");
        acceptButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                acceptButtonActionPerformed(evt);
            }
        });

        jPanel2.add(acceptButton);

        conflictPane.add(jPanel2);

        getContentPane().add(conflictPane);

        pack();
    }//GEN-END:initComponents

    private void acceptButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_acceptButtonActionPerformed
        enConflit = false;
        slavePane.removeAll();
        masterPane.removeAll();
        
        if(slaveRB.isSelected())
            this.fieldsAndValues = sendLoop.fieldsAndValues1;
        else if(masterRB.isSelected())
            this.fieldsAndValues = sendLoop.fieldsAndValues2;
        
        
        
        conflictPane.setVisible(false);
        waitingPane.setVisible(true);
        sendLoop.notifyLoop();
    }//GEN-LAST:event_acceptButtonActionPerformed

    private void slaveRBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_slaveRBActionPerformed
         if(masterRB.isSelected())
            masterRB.setSelected(false);
    }//GEN-LAST:event_slaveRBActionPerformed

    private void masterRBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_masterRBActionPerformed
        if(slaveRB.isSelected())
            slaveRB.setSelected(false);
    }//GEN-LAST:event_masterRBActionPerformed


    


    /** Creates a new instance of Synchronize */

/***********************************************************************************************/



class SendLoop extends Thread
{
    private Synchronize papa;
    private Hashtable fieldsAndValues3 = new Hashtable();
    private String table;
    private Hashtable fieldsAndValues1;
    private Hashtable fieldsAndValues2;
    private String tableName = new String();
    private Connection connex;
    private String tableStart = new String();
    private Hashtable fieldsAndValuesStart = new Hashtable();
    private Vector tableNiveaux = new Vector();
    
	public SendLoop(Synchronize papa, Connection connex, Vector tableLevels){
            tableNiveaux = tableLevels;
            this.connex = connex;
            this.papa = papa;
            this.table = table;
            this.fieldsAndValues1 = fieldsAndValues1;
            start();
            
        }
        
        
    public void notifyLoop()
    {
            synchronized(this)
            {
                    notify();
            }
//            return fieldsAndValues3;
    }

        
/*    public void run(){
               System.out.println("debut de loop");

        try{
            synchronized (this){
                
                    ResultSet journalRSET2 = destConnex.prepareStatement("SELECT * FROM JOURNAL").executeQuery();
                    fieldsAndValues2 = new Hashtable();
                    boolean breakinfo = false;
                    while(journalRSET2.next()){
                        if(journalRSET2.getString("JO_TABNOM").compareTo(tableStart) == 0){
                            isUpdate = true;
                            fieldsAndValues2 = parseJO(journalRSET2.getString("JO_NOUVAL"),journalRSET2.getString("JO_TABNOM"));
                            isUpdate = false;
                            Enumeration journalLineKeys = fieldsAndValues2.keys();
                            //while(journalLineKeys.hasMoreElements()){
                            //    String cle = (String)journalLineKeys.nextElement();
                                ResultSet primKeysRSET = destConnex.prepareStatement("DESC " + tableStart).executeQuery();
                                while(primKeysRSET.next()){
                                    if(primKeysRSET.getString("Key").compareTo("PRI") == 0){
                                        System.out.println("On teste : " + primKeysRSET.getString("Field"));
                                        System.out.println(fieldsAndValues2.get(primKeysRSET.getString("Field")) + " <====> " + fieldsAndValuesStart.get(primKeysRSET.getString("Field")));
                                        if(((String)fieldsAndValues2.get(primKeysRSET.getString("Field"))).compareTo((String)fieldsAndValuesStart.get(primKeysRSET.getString("Field"))) != 0){
                                            breakinfo = true;
                                            System.out.println("il faut casser");
                                            break;
                                        }else{
                                            System.out.println("il faut choisir");// fieldsAndValues1 = new chooseUpdateLineDialog(fieldsAndValues1, fieldsAndValues2);
                                            conflictPane.setVisible(true);
                                            waitingPane.setVisible(false);
                                            enConflit = true;
                                            remplirConflictPane(fieldsAndValuesStart, fieldsAndValues2);
                                            //while(enConflit){
                                                try{
                                                wait();
                                                }catch (InterruptedException e){}
                                            //}
                                        }
                                        if(breakinfo)
                                            break;
                                    }
                                    if(breakinfo)
                                        break;
                                }
     
                                System.out.println("BREAK !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
                                break;
                        }
                    }
                
            }
            
        }catch(Exception e){							
			System.out.println("RUN ERROR !!!!!!!!!!:"+e);
        }
       System.out.println("fin de loop");

    }*/
        // private void lireJournal(String tableName){
    public void run(){
        try{
            synchronized(this){
                for(int i = 0 ; i < tableNiveaux.size() ; i++ ){
                    Vector tableNiveau = (Vector)tableNiveaux.get(i);
                    for(int j = 0 ; j < tableNiveau.size() ; j++ ){    
                        tableName = (String)tableNiveau.get(j);
                        
                        System.out.println(tableName);
                        ResultSet journalRSET = connex.prepareStatement("SELECT * FROM EXT_JO WHERE JO_TABNOM = '" + tableName + "' ORDER BY JO_ID" ).executeQuery();
                        while(journalRSET.next()){
                            fieldsAndValues = new Hashtable();
                            lastfieldsAndValues = new Hashtable();
                            if(journalRSET.getString("JO_OPERATION").compareTo("I") == 0 ){
                                System.out.println("Action Trouvée : INSERT");
                                fieldsAndValues = parseJO(journalRSET.getString("JO_NOUVAL"),journalRSET.getString("JO_TABNOM"), false);
                                System.out.println("Parsage de la ligne fini");
                                insertAction(fieldsAndValues, journalRSET.getString("JO_TABNOM"));
                            }else if(journalRSET.getString("JO_OPERATION").compareTo("U") == 0 ){
                                    System.out.println("Action Trouvée : UPDATE");
                                    isUpdate = true;
                                    Hashtable fieldsAndValues = parseJO(journalRSET.getString("JO_NOUVAL"),journalRSET.getString("JO_TABNOM"), false);
                                    isUpdate = false;
                                    System.out.println("=======PARSAGE DES VALEURS PRECEDENTES======");
                                    lastfieldsAndValues = parseJO(journalRSET.getString("JO_PRECVAL"),journalRSET.getString("JO_TABNOM"), true);
                                    System.out.println("=======FIN DU PARSAGE DES VALEURS PRECEDENTES======");

                                    System.out.println("Parsage de la ligne fini");
                                    tableStart = journalRSET.getString("JO_TABNOM");
                                    fieldsAndValuesStart = fieldsAndValues;

                                    ResultSet journalRSET2 = connex.prepareStatement("SELECT * FROM JOURNAL").executeQuery();
                                    fieldsAndValues2 = new Hashtable();
                                    boolean breakinfo = false;
                                    while(journalRSET2.next()){
                                        if(journalRSET2.getString("JO_TABNOM").compareTo(tableStart) == 0){
                                            isUpdate = true;
                                            fieldsAndValues2 = parseJO(journalRSET2.getString("JO_NOUVAL"),journalRSET2.getString("JO_TABNOM"), false);
                                            isUpdate = false;
                                            Enumeration journalLineKeys = fieldsAndValues2.keys();
                                            //while(journalLineKeys.hasMoreElements()){
                                            //    String cle = (String)journalLineKeys.nextElement();
                                            ResultSet primKeysRSET = connex.prepareStatement("DESC " + tableStart).executeQuery();
                                            while(primKeysRSET.next()){
                                                if(primKeysRSET.getString("Key").compareTo("PRI") == 0){
                                                    System.out.println("On teste : " + primKeysRSET.getString("Field"));
                                                    System.out.println(fieldsAndValues2.get(primKeysRSET.getString("Field")) + " <====> " + fieldsAndValuesStart.get(primKeysRSET.getString("Field")));
                                                    if(((String)fieldsAndValues2.get(primKeysRSET.getString("Field"))).compareTo((String)fieldsAndValuesStart.get(primKeysRSET.getString("Field"))) != 0){
                                                        breakinfo = true;
                                                        System.out.println("il faut casser");
                                                        break;
                                                    }else{
                                                        System.out.println("il faut choisir");// fieldsAndValues1 = new chooseUpdateLineDialog(fieldsAndValues1, fieldsAndValues2);
                                                        conflictPane.setVisible(true);
                                                        waitingPane.setVisible(false);
                                                        enConflit = true;
                                                        remplirConflictPane(fieldsAndValuesStart, fieldsAndValues2);
                                                        try{
                                                            wait();
                                                        }catch (InterruptedException e){}
                                                    }
                                                    if(breakinfo)
                                                        break;
                                                }
                                                if(breakinfo)
                                                    break;
                                            }
                                            System.out.println("BREAK !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
                                            break;
                                        }
                                    }
                                    modifyAction(fieldsAndValues, journalRSET.getString("JO_TABNOM"));
                            }
                        }
                        
                    }
                }
            connex.prepareStatement("DELETE FROM EXT_JO").executeUpdate();
            connex.prepareStatement("DELETE FROM JOURNAL").executeUpdate();
            // dropSourceTable();
            // copyDataBase();
            JOptionPane.showMessageDialog(papa,"La synchronisation a été effectuée correctement","Synchronisation effectuée",JOptionPane.INFORMATION_MESSAGE,null);
            papa.dispose();

            }
        }catch(Exception e){
            System.out.println("[Synchronize][lireJournal] Exception : " + e);
            e.printStackTrace();
    }

        
    }
   
   private void copyDataBase(){
       try{
           for(int i = 0 ; i < tableNiveaux.size() ; i++ ){
               for(int j = 0 ; j < ((Vector)tableNiveaux.get(i)).size() ; j++ ){
                   String tableName = (String)((Vector)tableNiveaux.get(i)).get(j);
                   ResultSet selectRSET = connex.prepareStatement("SELECT * FROM " + tableName).executeQuery();
                   System.out.println("tableName : " + tableName);
                   String requette = "INSERT INTO ";
                   String fields = "(";
                   requette = requette + tableName + " (";
                   while(selectRSET.next()){
                        String zeroPrimKey = new String("");
                        Integer zeroPrimKeyID = new Integer("0");
                        ResultSet insertRSET;
                        ResultSetMetaData  selectRSETMD = selectRSET.getMetaData();
                        for(int k = 1 ; k <= selectRSETMD.getColumnCount() ; k++ ){
                            if(isPrimaryKey(selectRSETMD.getColumnName(k),tableName) && selectRSET.getString(k).compareTo("0") == 0){
                                zeroPrimKey = selectRSETMD.getColumnName(k);
                            }else{
                                fields = fields + "'" + selectRSET.getString(k) + "',";
                                requette = requette + selectRSETMD.getColumnName(k) + ",";
                            }
                        }
                        requette = requette.substring(0,requette.length()-1) + ")";
                        fields = fields.substring(0,fields.length()-1) + ")";
                        requette = requette + " VALUES" + fields; 
                        System.out.println("Requette : " + requette ) ;
                        connex.prepareStatement(requette).executeUpdate();
                        
                        if(zeroPrimKey.compareTo("") != 0){
                            insertRSET = connex.prepareStatement("select @@IDENTITY as 'ident'").executeQuery();
                            if(insertRSET.next()){
                                System.out.println("ID : " + insertRSET.getInt("ident"));
                                zeroPrimKeyID = new Integer(insertRSET.getInt("ident"));
                            }
                        }
                        
                        System.out.println("zeroPrimKeyID : " + zeroPrimKeyID);
                        if(zeroPrimKeyID.intValue() != 0){
                            connex.prepareStatement("UPDATE " + tableName + " SET " + zeroPrimKey + "=0 WHERE " + zeroPrimKey + "=" + zeroPrimKeyID).executeUpdate();
                            System.out.println("UPDATE " + tableName + " SET " + zeroPrimKey + "=0 WHERE " + zeroPrimKey + "=" + zeroPrimKeyID);
                        }
                        requette = "INSERT INTO " + tableName + " (";
                        fields = "(";
                   }
               }
           }
       }catch(Exception e){
           System.out.println("[Synchronize][copyDataBase] Exception : " + e );
           e.printStackTrace();
       }
   }
    
   private void dropSourceTable(){
       try{
           for(int i = 0 ; i < tableNiveaux.size() ; i++ ){
               for(int j = 0 ; j < ((Vector)tableNiveaux.get(i)).size() ; j++ ){
                   String tableName = (String)((Vector)tableNiveaux.get(i)).get(j);
                   connex.prepareStatement("DELETE FROM " + tableName).executeUpdate();
               }
           }
       }catch(Exception e){
           System.out.println("[Synchronize][copyDataBase] Exception : " +e );
           e.printStackTrace();
       }
   }
   
    public String primaryKey(String nomTable){
        try{
            DatabaseMetaData metadata = connex.getMetaData();
            ResultSet clefs = metadata.getPrimaryKeys(connex.getCatalog(),null,nomTable);
            while(clefs.next()){
               String nomColonne = clefs.getString("COLUMN_NAME");
               System.out.println("La colonne "+nomColonne+"est une clef primaire de "+nomTable);
               return nomColonne;
            }
        }catch(Exception e){
            System.out.println("[Synchronize][primaryKey] Exception : " + e );
            e.printStackTrace();
        }
        return "";
    }

    private void insertAction(Hashtable fieldsAndValues, String table){
        try{
            Enumeration keys = fieldsAndValues.keys();
            
            String field = (String)keys.nextElement();
            String fields = field + ",";
            String values = new String();
            
            Vector listeChamps = new Vector();
            int nbFields = 0;
            
            if(isPrimaryKey(fields.substring(0,fields.length()-1),table))
                fields = new String();
            else{
                //values = "'" + (String)fieldsAndValues.get(field) + "'" + ",";
                values = "?,";
                listeChamps.add((String)fieldsAndValues.get(field));
                nbFields++;
            }
            

            while(keys.hasMoreElements()){
                field = (String)keys.nextElement();
                System.out.println("field : " + field + " value : " +(String)fieldsAndValues.get(field) + " isPrimaryKey : " + isPrimaryKey(field, table));
                if(!isPrimaryKey(field, table) || parentsID.contains(table)){
                    nbFields++;
                    fields += field + ",";
                    // values += "'" + (String)fieldsAndValues.get(field) + "',";
                    listeChamps.add((String)fieldsAndValues.get(field));
                    values += "?,";
                }
            }

            values = "(" + values.substring(0, values.length()-1) + ")";
            fields = "(" + fields.substring(0, fields.length()-1) + ")";
            System.out.println("table : " + table);
            System.out.println("Fields : " + fields ) ;
            System.out.println("Values : " + values ) ;
        
            System.out.println("REQUETTE ====> INSERT INTO " + table + " " + fields + " values" + values);
            PreparedStatement requettePrepared = connex.prepareStatement("INSERT INTO " + table + " " + fields + " values" + values);
            
            for(int i = 0 ; i < nbFields ; i++){
                requettePrepared.setString(i+1,(String)listeChamps.get(i));
            }
            
            requettePrepared.executeUpdate();
            ResultSet insertRSET = connex.prepareStatement("select @@IDENTITY as 'ident'").executeQuery();
            if(insertRSET.next()){
                Integer lineID = new Integer(insertRSET.getInt("ident"));
                Hashtable a = new Hashtable();
                
                if(changedID.containsKey(table))
                    a = (Hashtable)changedID.get(table);
                    
                System.out.println("last ID : " + lastID + " new ID : " + lineID);
                a.put(lastID, lineID);
                if(!changedID.containsKey(table))
                    changedID.put(table, a);
            }
        }catch(Exception e){
            System.out.println("[Synchronize][insertAction] Exception : " + e);
            e.printStackTrace();
        }
        
    }    

    private void modifyAction(Hashtable fieldsAndValues, String table){
        Enumeration keys = fieldsAndValues.keys();
        String primKey = new String();
        Vector listeChamps = new Vector();
        int nbFields = 1;

        String requette = new String();
        String field = (String)keys.nextElement();
        isUpdate = false;
        // String requette = field + "='" + (String)fieldsAndValues.get(field) + "',";
        //if(!isPrimaryKey(field,table)){
            requette = field + "= ? , ";
            listeChamps.add((String)fieldsAndValues.get(field));
        //}else{
            if(isPrimaryKey(field,table))
                primKey = field + " = " + (String)lastfieldsAndValues.get(field) + " ";
        //}
        
        while(keys.hasMoreElements()){
            field = (String)keys.nextElement();
            //if(!isPrimaryKey(field, table)){
                nbFields++;
                requette = requette + field + "= ? , ";
                listeChamps.add((String)fieldsAndValues.get(field));
            //}else{
                if(isPrimaryKey(field,table)){
                    if(primKey.compareTo("") == 0)
                        primKey = field + " = " + (String)lastfieldsAndValues.get(field) + " ";
                    else
                        primKey += "AND " + field + " = " + (String)lastfieldsAndValues.get(field) + " ";
                }
            //}
        }
        
        requette = requette.substring(0, requette.length()-2);
        System.out.println("requette : " + requette + " primaryKeys : " + primKey);
System.out.println("UPDATE " + table + " SET " + requette + " WHERE " + primKey);
        
        try{
            PreparedStatement statement  = connex.prepareStatement("UPDATE " + table + " SET " + requette + " WHERE " + primKey);
            for(int i = 0 ; i < nbFields ; i++){
                statement.setString(i+1,(String)listeChamps.get(i));
            }
            statement.executeUpdate();

        }catch(Exception e){
            System.out.println("[Synchronize][modifyAction] Exception : " + e);
            e.printStackTrace();
        }
        
    }    

    private boolean isPrimaryKey(String valChamp, String table){
        boolean estPrimaire = false;
        try{
            ResultSet rsetDesc = connex.getMetaData().getPrimaryKeys(null, null, table);
            while(rsetDesc.next()){
                if(rsetDesc.getString("COLUMN_NAME").compareTo(valChamp) == 0)
                        estPrimaire = true;
            }
        }catch(Exception e){
            System.out.println("[Synchronize][isPrimaryKey] Exception : " + e);
            e.printStackTrace();
            return estPrimaire;
        }
        return estPrimaire;
    }
    
    private String verificationParent(String valChamp, String valContent){
        /*if(valContent.length() > 1)
            valContent = valContent.substring(0,valContent.length()-1);*/
        // ca prend les clef de la hashtable qui contient les hashtable qui contient les modifications
        System.out.println("------------------On teste les parents----------------");
            Enumeration key = changedID.keys();
            while(key.hasMoreElements()){
                String table = (String)key.nextElement();
                System.out.println("on teste les parents pour : " + table);
                String keyNom = primKey(table);
                if(keyNom.compareTo(valChamp) == 0){
                     Hashtable tableHash = (Hashtable)changedID.get(table);
                     System.out.println("Trouvééééééééééé meme champ : " + valChamp + " " + valContent);
                     if(valContent.indexOf(".") != -1)
                            valContent = valContent.substring(0,valContent.indexOf("."));
                     Integer valContentInt = new Integer(valContent);
                     if(tableHash.containsKey(valContentInt)){
                         System.out.println("contient la clé : " + valContentInt + " sous la forme : " + tableHash.get(valContentInt));
                         if(tableHash.get(valContentInt) != valContentInt){
                            valContentInt = (Integer)tableHash.get(valContentInt);
                            valContent = valContentInt.toString();
                            System.out.println("nouveau valContent : " + valContent);
                            return valContent;
                        }else
                            return valContent;
                    }
                }
            }
        System.out.println("------------------Fini de tester les parents----------------");
        return valContent;
/*        Enumeration key = changedID.keys();
        while(key.hasMoreElements()){
            String table = (String)key.nextElement();
            System.out.println("On teste la table parent : " + table);
            // Ca regarde quel est le nom du champ de la clef primaire
            String keyNom = new String();
            try{
                // ca selectionne la description de la table
                ResultSet verifRSET = connex.prepareStatement("DESC " + table).executeQuery();
                // Ca prend ligne par ligne du resultset
                while(verifRSET.next()){
                    // Ca prend la valeur du champ Key pour la ligne actuelle
                    String keyTable = verifRSET.getString("Key");
                    // Ca verifie si elle est primaire
                    if(keyTable.compareTo("PRI") == 0){
                        // Si elle l'est on prend la valeur du champ qui est clé primaire
                        keyNom = verifRSET.getString("Field");
                        // On compare a la valeur du champ qu'on veut tester
                        if(keyNom.compareTo(valChamp) == 0){
                            // Si on a trouvé le meme champ on le fait savoir et on 
                            Hashtable tableHash = (Hashtable)changedID.get(table);
                            System.out.println("Trouvééééééééééé meme champ : " + valChamp + " " + valContent);
                            if(isPrimaryKey(valChamp, table) && valContent.indexOf(".") != -1)
                                valContent = valContent.substring(0,valContent.indexOf("."));
                            Integer valContentInt = new Integer(valContent);
                            if(tableHash.containsKey(valContentInt)){
                                System.out.println("contient la clé : " + valContentInt);
                                // Hashtable priID = (Hashtable)tableHash.get(valContentInt);
                                if(tableHash.get(valContentInt) != valContentInt){
                                    valContentInt = (Integer)tableHash.get(valContentInt);
                                    valContent = valContentInt.toString();
                                    System.out.println("nouveau valContent : " + valContent);
                                    return valContent;
                                }else
                                    return valContent;
                            }
                        }
                    }
                }
            }catch(Exception e){
                System.out.println("[Synchronize][verificationParent] Exception : " + e );
                e.printStackTrace();
            }
        }*/
        
    }
    
    private String primKey(String table){
        String primKey = new String();
        try{
            // ca selectionne la description de la table
            ResultSet verifRSET = connex.prepareStatement("DESC " + table).executeQuery();
            // Ca prend ligne par ligne du resultset
            while(verifRSET.next()){
                // Ca prend la valeur du champ Key pour la ligne actuelle
                String keyTable = verifRSET.getString("Key");
                // Ca verifie si elle est primaire
                if(keyTable.compareTo("PRI") == 0){
                    // Si elle l'est on prend la valeur du champ qui est clé primaire
                    primKey = verifRSET.getString("Field");
                }
            }
        }catch(Exception e){
            System.out.println("[Synchronize][verificationParent] Exception : " + e );
            e.printStackTrace();
        }
        return primKey;
    }

    private Hashtable parseJO(String parseString, String table,boolean getAll){
        System.out.println("On parse une ligne pour la table : " + table);
        Hashtable localfieldsAndValues = new Hashtable();
        int k = parseString.length();
        for( int i = 0 ; i < k; ){
            parseString = parseString + "#";
            i = parseString.indexOf("###",i);
            int j = parseString.indexOf("###",i + 3);
            String valActuelle = parseString.substring(i+3,j);
            valActuelle = valActuelle + "#";
            // chope la valeur du champ
            String valChamp = new String();
            
            valChamp = valActuelle.substring( 0 ,valActuelle.indexOf("=>"));
            
            // chope la valeur du contenu du champ
            String valContent = valActuelle.substring(valActuelle.indexOf("=>") + 2,valActuelle.indexOf("#",valActuelle.indexOf("=>") + 2));
            // on traite les boolean
            if(valContent.compareTo("true") == 0)
                valContent = "1";
            else if(valContent.compareTo("false") == 0 )
                valContent = "0";
            
            
            // verifie si c'est un champ de clef primaires ou pas de cette table
            if(!isPrimaryKey(valChamp, table) || getAll){
                System.out.println("localfieldsAndValues : champ :" + valChamp + " , content : " + valContent);
                // si ca n'en est pas un, il l'insere dans une Hashtable
                localfieldsAndValues.put(valChamp, valContent);
            }else{
                System.out.println("Anciennes Valeurs : valChamp : " + valChamp + " valContent : " + valContent);
                // on verifie si il y a deja un niveau superieur qui a une clef primaire de meme nom et de meme ID
                String valContent2 = verificationParent(valChamp,valContent);
                //valContent = valContent.substring(0,valContent.length());
                // valContent2 = valContent2.substring(0,valContent2.length()-2);
                valContent = valContent2;
                System.out.println("Nouvelles Valeurs : valContent : " + valContent + " valContent2 : " + valContent2);
//                if(valContent.compareTo(valContent2) != 0){
                    localfieldsAndValues.put(valChamp,  valContent2);
                    System.out.println("la valeur de cette clé primaire a change : " +valChamp +" => " + valContent2);
//                }
                    if( isPrimaryKey(valChamp, table) && valContent.indexOf(".") != -1)
                        valContent = valContent.substring(0,valContent.indexOf("."));
                    System.out.println("=============================\n" +
                                        "valContent : " + valContent);
                    System.out.println("valContent2 : " + valContent2 + 
                                        "\n============================");
                    localfieldsAndValues.put(valChamp, valContent);
                    lastID = new Integer(valContent);
            }

            i = j;
        }
        return localfieldsAndValues;
    }

    private void  remplirConflictPane(Hashtable fieldsAndValues1, Hashtable fieldsAndValues2){
        Enumeration keys1 = fieldsAndValues1.keys();
        Enumeration keys2 = fieldsAndValues2.keys();
        
        while(keys1.hasMoreElements()){
            String key = (String)keys1.nextElement();
            String champName = (String)champsName.get(key);
            String champValue = (String)fieldsAndValues1.get(key);
            slavePane.add(new javax.swing.JLabel(champName + " : " + champValue));
        }
        while(keys2.hasMoreElements()){
            String key = (String)keys2.nextElement();
            String champName = (String)champsName.get(key);
            String champValue = (String)fieldsAndValues2.get(key);
            masterPane.add(new javax.swing.JLabel(champName + " : " + champValue));
        }
        
    }    



    public void parcourNiveau(Vector tableNiveau){
        for(int j = 0 ; j < tableNiveau.size() ; j++ ){
                //lireJournal();
                tableName = (String)tableNiveau.get(j);
                start();
        }
    }

    public void parcourListeNiveaux(Vector tableNiveaux){
        for(int i = 0 ; i < tableNiveaux.size() ; i++ ){
            parcourNiveau((Vector)tableNiveaux.get(i));
        }
    }
    
    public void synchronize(Connection connex, Vector tableLevels) {
    //    this.sourceConnex = sourceConnex;
      //  this.destConnex = destConnex;
        parcourListeNiveaux(tableLevels);
    }    
}
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    public javax.swing.JProgressBar Progress;
    private javax.swing.JButton acceptButton;
    private javax.swing.JPanel conflictPane;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JPanel jPanel5;
    private javax.swing.JPanel jPanel6;
    private javax.swing.JPanel jPanel7;
    private javax.swing.JPanel masterPane;
    private javax.swing.JRadioButton masterRB;
    private javax.swing.JScrollPane masterSP;
    private javax.swing.JPanel radioPane;
    private javax.swing.JPanel slavePane;
    private javax.swing.JRadioButton slaveRB;
    private javax.swing.JScrollPane slaveSP;
    private javax.swing.JPanel waitingPane;
    // End of variables declaration//GEN-END:variables
    
}


